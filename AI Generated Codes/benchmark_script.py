"""
Filename: ai_benchmark_script.py
Description: 
    Automates the benchmarking of the C prime number generator.
    It runs the executable with an increasing number of processes 
    and plots the Time vs. N graph using Matplotlib.
    
Generated by AI Assistant.
"""

import subprocess  # To run the C executable
import matplotlib.pyplot as plt  # For plotting graphs
import sys
import os

# Configuration Constants
EXECUTABLE_NAME = "./ai_fastprime_solution" # Ensure this matches the compiled output
RANGES_TO_TEST = [
    (1000, 10000),      # Small workload
    (50000, 100000),    # Medium workload
    (100000, 300000)    # Large workload (Parallelism visible here)
]

def compile_c_code():
    """
    Compiles the C code using GCC.
    Returns True if successful, False otherwise.
    """
    print("[AI-Info] Compiling C code...")
    compile_cmd = ["gcc", "fastprime_solution.c", "-o", "ai_fastprime_solution", "-lm"]
    result = subprocess.run(compile_cmd)
    
    if result.returncode != 0:
        print("[AI-Error] Compilation failed.")
        return False
    return True

def get_cpu_count():
    """
    Detects the number of logical CPUs on the machine using lscpu.
    """
    try:
        # Running lscpu to get detailed CPU info
        output = subprocess.check_output("lscpu", shell=True).decode()
        for line in output.split('\n'):
            if "CPU(s):" in line and "NUMA" not in line:
                # Extract the number from the line "CPU(s):      8"
                return int(line.split(':')[1].strip())
    except Exception as e:
        print(f"[AI-Warning] Could not run lscpu: {e}. Defaulting to os.cpu_count()")
        return os.cpu_count()

def perform_benchmark():
    # Step 1: Compile
    if not compile_c_code():
        return

    # Step 2: Determine hardware capabilities
    max_logical_cores = get_cpu_count()
    print(f"[AI-Info] Detected {max_logical_cores} logical cores.")
    
    # Prepare the plot
    plt.figure(figsize=(12, 8))
    
    # Step 3: Iterate through different ranges
    for (start, end) in RANGES_TO_TEST:
        print(f"\n--- Testing Range: {start} to {end} ---")
        
        process_counts = []
        execution_times = []
        
        # Test from 1 process up to (Cores + 4) to see the degradation point
        test_limit = max_logical_cores + 4
        
        for n in range(1, test_limit + 1):
            try:
                # Construct command: ./program <start> <end> <n_procs>
                cmd = [EXECUTABLE_NAME, str(start), str(end), str(n)]
                
                # Run the process and capture stdout
                result = subprocess.run(cmd, capture_output=True, text=True)
                
                # Parse the time from the C program's output
                time_taken = float(result.stdout.strip())
                
                process_counts.append(n)
                execution_times.append(time_taken)
                
                print(f"   Processes: {n} | Time: {time_taken:.6f} sec")
                
            except ValueError:
                print(f"   [AI-Error] Failed to parse output for n={n}")
            except Exception as e:
                print(f"   [AI-Error] Runtime error: {e}")

        # Plot the line for this specific range
        plt.plot(process_counts, execution_times, marker='o', label=f'Range {start}-{end}')

    # Step 4: Finalize and Save Plot
    plt.xlabel('Number of Child Processes (n)')
    plt.ylabel('Execution Time (seconds)')
    plt.title(f'Performance Analysis: Parallel Prime Generation\n(Hardware: {max_logical_cores} Logical Cores)')
    plt.legend()
    plt.grid(True)
    
    output_filename = 'performance_plot.png'
    plt.savefig(output_filename)
    print(f"\n[AI-Success] Benchmark complete. Plot saved as '{output_filename}'")

if __name__ == "__main__":
    perform_benchmark()