/*
 * Filename: ai_fastprime_solution.c
 * Description: 
 * This program computes prime numbers in a given range [rl, rh] using multiple 
 * child processes to utilize multi-core architecture.
 * * Usage: ./ai_fastprime <low> <high> <num_processes>
 * * Generated by AI Assistant.
 */

#include <stdio.h>      // Standard I/O functions
#include <stdlib.h>     // Standard library for exit, atoi, malloc
#include <unistd.h>     // POSIX API for fork, close, write
#include <sys/wait.h>   // For wait()
#include <sys/time.h>   // For gettimeofday()
#include <fcntl.h>      // For file control options (O_CREAT, etc.)
#include <signal.h>     // For signal handling
#include <math.h>       // For sqrt() function in prime check

// Global array to store child Process IDs (PIDs) for cleanup
pid_t *global_pids = NULL;
int global_num_procs = 0;

/*
 * Function: handle_sigint
 * ----------------------------
 * Signal handler for SIGINT (Ctrl+C).
 * Ensures that if the parent is killed, all child processes are also killed
 * to prevent zombie processes or orphaned workers.
 *
 * sig: The signal number (expected SIGINT)
 */
void handle_sigint(int sig) {
    printf("\n[AI-Log] Received SIGINT. Terminating all child processes...\n");
    if (global_pids != NULL) {
        for (int i = 0; i < global_num_procs; i++) {
            if (global_pids[i] > 0) {
                kill(global_pids[i], SIGKILL);
            }
        }
    }
    free(global_pids);
    exit(1);
}

/*
 * Function: is_prime_number
 * ----------------------------
 * Determines if a given integer n is a prime number.
 * Returns 1 if prime, 0 otherwise.
 * Optimization: Checks divisibility up to sqrt(n).
 */
int is_prime_number(int n) {
    if (n <= 1) return 0;
    if (n == 2 || n == 3) return 1;
    if (n % 2 == 0 || n % 3 == 0) return 0;
    
    // Check for factors from 5 up to sqrt(n)
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0)
            return 0;
    }
    return 1;
}

int main(int argc, char *argv[]) {
    // 1. Argument Validation
    if (argc != 4) {
        fprintf(stderr, "Error: Invalid arguments.\n");
        fprintf(stderr, "Usage: %s <start_range> <end_range> <num_processes>\n", argv[0]);
        return 1;
    }

    // 2. Parse Arguments
    int rl = atoi(argv[1]); // Range Low
    int rh = atoi(argv[2]); // Range High
    int n_procs = atoi(argv[3]); // Number of Processes

    if (n_procs <= 0) {
        fprintf(stderr, "Error: Number of processes must be > 0. Setting to 1.\n");
        n_procs = 1;
    }

    // 3. Register Signal Handler
    signal(SIGINT, handle_sigint);

    // 4. Prepare File
    // Open the file with O_TRUNC to clear previous content.
    int fd_setup = open("prime.txt", O_WRONLY | O_CREAT | O_TRUNC, 0666);
    if (fd_setup < 0) {
        perror("[AI-Error] Failed to create file");
        return 1;
    }
    close(fd_setup);

    // 5. Memory Allocation for PIDs
    global_num_procs = n_procs;
    global_pids = (pid_t *)malloc(n_procs * sizeof(pid_t));
    if (global_pids == NULL) {
        perror("[AI-Error] Memory allocation failed");
        return 1;
    }

    // 6. Start Timer
    struct timeval start_time, end_time;
    gettimeofday(&start_time, NULL);

    // 7. Calculate Workload Distribution
    int total_numbers = rh - rl + 1;
    int chunk_size = total_numbers / n_procs;
    int remainder = total_numbers % n_procs;
    int current_rl = rl;

    // 8. Fork Child Processes
    for (int i = 0; i < n_procs; i++) {
        // Calculate specific range for this child
        int range_len = chunk_size + (i < remainder ? 1 : 0);
        int my_start = current_rl;
        int my_end = current_rl + range_len - 1;
        current_rl += range_len;

        pid_t pid = fork();

        if (pid < 0) {
            perror("[AI-Error] Fork failed");
            // Cleanup logic would go here in a production system
            exit(1);
        } 
        else if (pid == 0) {
            // --- CHILD PROCESS EXECUTION ---
            
            // Re-open file in APPEND mode so multiple children can write
            int fd = open("prime.txt", O_WRONLY | O_APPEND);
            if (fd < 0) {
                perror("Child failed to open file");
                exit(1);
            }

            char buffer[1024]; // Temporary buffer for string formatting
            
            // Iterate through the assigned sub-range
            for (int num = my_start; num <= my_end; num++) {
                if (is_prime_number(num)) {
                    // Format the number into a string and write it
                    int len = sprintf(buffer, "%d\n", num);
                    write(fd, buffer, len);
                }
            }
            
            close(fd);
            exit(0); // Child must exit here
        } 
        else {
            // --- PARENT PROCESS ---
            // Store the child PID
            global_pids[i] = pid;
        }
    }

    // 9. Wait for Completion
    // The parent must wait for all forked children to finish
    for (int i = 0; i < n_procs; i++) {
        wait(NULL);
    }

    // 10. Stop Timer & Calculate Duration
    gettimeofday(&end_time, NULL);
    double elapsed_time = (end_time.tv_sec - start_time.tv_sec) + 
                          (end_time.tv_usec - start_time.tv_usec) / 1000000.0;

    // 11. Output Result
    // Print only the time as requested for the Python script parser
    printf("%f\n", elapsed_time);

    // 12. Cleanup
    free(global_pids);
    return 0;
}